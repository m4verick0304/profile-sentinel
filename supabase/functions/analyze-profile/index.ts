import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface ProfileInput {
  username: string;
  account_age: number;       // days
  posts_count: number;
  followers_count: number;
  following_count: number;
  bio_length: number;        // characters
  username_flags: {
    numbers_heavy?: boolean;
    no_profile_pic?: boolean;
    random_characters?: boolean;
    very_short?: boolean;
  };
}

interface TopFactor {
  factor: string;
  description: string;
  impact: 'high' | 'medium' | 'low';
}

function analyzeProfile(input: ProfileInput): { risk_score: number; label: string; top_factors: TopFactor[] } {
  const factors: TopFactor[] = [];
  let score = 0;

  // 1. Account age score (newer = riskier)
  const ageDays = input.account_age;
  if (ageDays < 30) {
    score += 25;
    factors.push({ factor: 'Very new account', description: `Account is only ${ageDays} days old — a common trait of fake profiles.`, impact: 'high' });
  } else if (ageDays < 180) {
    score += 12;
    factors.push({ factor: 'Relatively new account', description: `Account is ${ageDays} days old, which is below average for established profiles.`, impact: 'medium' });
  }

  // 2. Follower/Following ratio
  const ratio = input.following_count > 0 ? input.followers_count / input.following_count : input.followers_count;
  if (ratio < 0.1 && input.following_count > 100) {
    score += 20;
    factors.push({ factor: 'Abnormal following ratio', description: `Follows ${input.following_count} accounts but only has ${input.followers_count} followers — a classic bot signal.`, impact: 'high' });
  } else if (ratio > 100 && input.followers_count > 10000) {
    // Very high followers with low following could be legit celeb but flag it
    score += 5;
    factors.push({ factor: 'Unusually high follower ratio', description: `Extremely high followers vs. following may indicate purchased followers.`, impact: 'low' });
  }

  // 3. Posts count relative to account age
  const postsPerDay = ageDays > 0 ? input.posts_count / ageDays : 0;
  if (postsPerDay > 20) {
    score += 20;
    factors.push({ factor: 'Abnormal posting frequency', description: `Averages ${postsPerDay.toFixed(1)} posts/day — far above human capability.`, impact: 'high' });
  } else if (input.posts_count === 0) {
    score += 15;
    factors.push({ factor: 'No posts found', description: 'Account has zero posts, which is unusual for active users.', impact: 'medium' });
  }

  // 4. Bio length
  if (input.bio_length === 0) {
    score += 10;
    factors.push({ factor: 'Empty bio', description: 'No bio text — real users typically introduce themselves.', impact: 'medium' });
  } else if (input.bio_length < 10) {
    score += 5;
    factors.push({ factor: 'Very short bio', description: `Bio is only ${input.bio_length} characters — minimal self-identification.`, impact: 'low' });
  }

  // 5. Username flags
  const flags = input.username_flags || {};
  if (flags.numbers_heavy) {
    score += 10;
    factors.push({ factor: 'Username has many numbers', description: 'Number-heavy usernames are frequently generated by bot creation scripts.', impact: 'medium' });
  }
  if (flags.no_profile_pic) {
    score += 10;
    factors.push({ factor: 'No profile picture', description: 'Missing profile picture is a strong indicator of an automated or spam account.', impact: 'medium' });
  }
  if (flags.random_characters) {
    score += 12;
    factors.push({ factor: 'Random-looking username', description: 'Username appears machine-generated with random character sequences.', impact: 'high' });
  }
  if (flags.very_short) {
    score += 5;
    factors.push({ factor: 'Very short username', description: 'Short usernames may indicate account squatting or automation.', impact: 'low' });
  }

  // Clamp score to 0–100
  const risk_score = Math.min(100, Math.max(0, score));

  // Determine label
  let label: string;
  if (risk_score >= 65) label = 'fake';
  else if (risk_score >= 35) label = 'suspicious';
  else label = 'real';

  // Return top 4 factors sorted by impact
  const impactOrder = { high: 0, medium: 1, low: 2 };
  const top_factors = factors
    .sort((a, b) => impactOrder[a.impact] - impactOrder[b.impact])
    .slice(0, 4);

  return { risk_score, label, top_factors };
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
    );

    // Verify user
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: userError } = await supabase.auth.getUser(token);
    if (userError || !user) {
      return new Response(JSON.stringify({ error: 'Invalid token' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const input: ProfileInput = await req.json();

    // Run mock ML scoring
    const result = analyzeProfile(input);

    // Save to database
    const { data: savedResult, error: insertError } = await supabase
      .from('analysis_results')
      .insert({
        user_id: user.id,
        username: input.username,
        account_age: input.account_age,
        posts_count: input.posts_count,
        followers_count: input.followers_count,
        following_count: input.following_count,
        bio_length: input.bio_length,
        username_flags: input.username_flags,
        risk_score: result.risk_score,
        label: result.label,
        top_factors: result.top_factors,
      })
      .select()
      .single();

    if (insertError) {
      console.error('Insert error:', insertError);
      return new Response(JSON.stringify({ error: 'Failed to save result' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    return new Response(JSON.stringify({ ...result, id: savedResult.id }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (err) {
    console.error(err);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
